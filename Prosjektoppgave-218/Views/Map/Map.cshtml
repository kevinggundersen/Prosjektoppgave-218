@{
    ViewData["Title"] = "Kart";
}

<div class="container-fluid" id="mapcontainer">
    <h1></h1>

    <div id="map" style="height: 600px; width: 100%;"></div>
</div>

@section Styles {
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin="" />

    <!-- Leaflet Control Geocoder CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
}

@section Scripts {
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <!-- Leaflet Control Geocoder plugin -->
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

    <!-- Proj4 and Proj4Leaflet for reprojecting EPSG:32633 → EPSG:4326 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4leaflet/1.0.2/proj4leaflet.js"></script>

    <script>
        // Define UTM zone 33N projection
        proj4.defs("EPSG:32633", "+proj=utm +zone=33 +datum=WGS84 +units=m +no_defs");
        // Define EPSG:25832 projection (for your new layers)
        proj4.defs("EPSG:25832", "+proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs");

        console.log("Map script loaded");

        // Initialize map
        var map = L.map('map').setView([58.1633, 8.0025], 8);

        // Helper for WMS GetFeatureInfo (keep if needed for other layers)
        function getFeatureInfoUrl(map, latlng, baseUrl, options) {
            const point = map.latLngToContainerPoint(latlng, map.getZoom());
            const size = map.getSize();
            const params = {
                request: 'GetFeatureInfo',
                service: 'WMS',
                srs: 'EPSG:3857',
                styles: '',
                transparent: true,
                version: '1.3.0',
                format: 'image/png',
                bbox: map.getBounds().toBBoxString(),
                height: size.y,
                width: size.x,
                layers: options.layers,
                query_layers: options.query_layers,
                info_format: options.info_format,
                i: Math.floor(point.x),
                j: Math.floor(point.y)
            };
            return baseUrl + L.Util.getParamString(params, baseUrl, true);
        }

        // Base layers
        var kartverket = L.tileLayer('https://cache.kartverket.no/v1/wmts/1.0.0/topo/default/webmercator/{z}/{y}/{x}.png', {
            maxZoom: 19,
            attribution: '&copy; Kartverket'
        }).addTo(map);

        var matrikkelkart = L.tileLayer.wms('https://wms.geonorge.no/skwms1/wms.matrikkelkart', {
            layers: 'Matrikkelkart',
            format: 'image/png',
            transparent: true,
            attribution: '&copy; Kartverket'
        }).addTo(map);

        var elveg2 = L.tileLayer.wms('https://wms.geonorge.no/skwms1/wms.vegnett2', {
            layers: 'vegnett2',
            format: 'image/png',
            transparent: true,
            attribution: '&copy; Kartverket'
        }).addTo(map);

        // Layer groups for the new point layers
        var sykehusLayer = L.layerGroup();
        var politiLayer = L.layerGroup();
        var brannLayer = L.layerGroup();
        // Create a separate layer group for flood zones to manage them easily
        var floodLayerGroup = L.layerGroup().addTo(map); // Add to map initially

        // Layer control
        var baseMaps = { "Kartverket": kartverket };
        var overlayMaps = {
            "Matrikkelkart": matrikkelkart,
            "Vegnett": elveg2,
            "Sykehus": sykehusLayer,
            "Politi/Fengsel": politiLayer,
            "Brann/Ambulanse": brannLayer
        };
        // Add the flood layer group to the control
        var layerControl = L.control.layers(baseMaps, overlayMaps, { collapsed: false }).addTo(map);
        layerControl.addOverlay(floodLayerGroup, 'Flomsoner'); // Add the layer group to the control

        // helper to request only the current bbox
        function loadFloodInView() {
            const b = map.getBounds();
            const sw = b.getSouthWest();
            const ne = b.getNorthEast();

            // The server function get_flomsoner_bbox expects min_lng, min_lat, max_lng, max_lat.
            // Assuming the server function is designed to receive WGS84 bounds
            // (which Leaflet's getBounds() provides) and perform the
            // intersection check against the EPSG:32633 flood zone data internally,
            // sending WGS84 bounds directly is correct.

            console.log(`Workspaceing flood data for bounds (WGS84): SW(${sw.lng}, ${sw.lat}), NE(${ne.lng}, ${ne.lat})`);

            fetch(`/Map/FloodInView?minx=${sw.lng}&miny=${sw.lat}&maxx=${ne.lng}&maxy=${ne.lat}`)
                .then(r => {
                    if (!r.ok) {
                        console.error("Flood data request failed:", r.status, r.statusText);
                        return Promise.reject('Network response was not ok.');
                    }
                    console.log("Flood data request successful:", r);
                    return r.json();
                })
                .then(fc => {
                    console.log("Flood GeoJSON received:", fc);

                    // Check if the GeoJSON is valid and is a FeatureCollection
                    if (!fc || fc.type !== 'FeatureCollection' || !Array.isArray(fc.features)) {
                        console.error('Invalid or empty GeoJSON FeatureCollection structure received:', fc);
                        // Clear the layer group if invalid data is received
                        floodLayerGroup.clearLayers();
                        return;
                    }

                    console.log(`Processing ${fc.features.length} flood zone features`);

                    // Clear existing layers from the floodLayer group
                    floodLayerGroup.clearLayers();

                    // Add the entire FeatureCollection as a single L.geoJSON layer
                    // Use the coordsToLatLng option to reproject from EPSG:32633
                    L.geoJSON(fc, {
                        // Define the function to transform coordinates from EPSG:32633 to EPSG:4326
                        coordsToLatLng: coords => {
                            // 'coords' here is a single [x, y] array representing one vertex
                            // This function is called for EVERY coordinate in the geometry
                            try {
                                // proj4 expects [x, y], returns [longitude, latitude]
                                var p = proj4('EPSG:32633', 'EPSG:4326', coords);
                                // Leaflet expects LatLng(latitude, longitude)
                                return L.latLng(p[1], p[0]);
                            } catch (e) {
                                console.error("Error transforming flood zone coordinates:", coords, e);
                                // Return a dummy LatLng or null to indicate an issue
                                return L.latLng(0, 0); // Or return null, though Leaflet might error
                            }
                        },
                        style: {
                            color: '#0077be', // Style for the flood zones (polygons)
                            weight: 2,
                            fillOpacity: 0.4
                        },
                        onEachFeature: (feature, layer) => {
                            // Add popup with feature properties
                            var props = feature.properties || {};
                            // Adjust property name based on the console output: 'fid' seems like a good candidate for display
                            var popupContent = `<b>Zone ID:</b> ${props.fid || 'N/A'}<br>`;
                            // Add other relevant properties from the 'properties' object in the console output if needed
                            // e.g., popupContent += `<b>Interval:</b> ${props.gjentaksintervall || 'N/A'}`;
                            layer.bindPopup(popupContent);
                        }
                    }).addTo(floodLayerGroup); // Add the new L.geoJSON layer to the floodLayer group

                    console.log('Flood layer processing complete');
                })
                .catch(err => {
                    console.error('Flood In-View load error', err);
                    // Clear the layer group on error
                    floodLayerGroup.clearLayers();
                });
        }

        // load initially
        loadFloodInView();

        // reload each time the user pans or zooms
        map.on('moveend', loadFloodInView);

        // Geocoder control
        var geocoder = L.Control.geocoder({ defaultMarkGeocode: false, placeholder: "Søk..." })
            .addTo(map);
        geocoder.getContainer().setAttribute('title', 'Søk etter steder');
        geocoder.on('markgeocode', function (e) {
            map.setView(e.geocode.center, 16);
            L.marker(e.geocode.center).addTo(map)
                .bindPopup(e.geocode.name).openPopup();
        });

        // (Optional) Your WFS and click‐to‐info code can follow here…
        function transformCoordinates(feature) {
            if (feature.geometry && feature.geometry.coordinates) {
                if (feature.geometry.type === 'Point') {
                    const transformed = proj4("EPSG:25832", "EPSG:4326", feature.geometry.coordinates);
                    feature.geometry.coordinates = [transformed[0], transformed[1]];
                    console.log("Transformed Point:", feature.geometry.coordinates);
                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                    feature.geometry.coordinates = feature.geometry.coordinates.map(level1 => {
                        return level1.map(level2 => {
                            return level2.map(coord => {
                                const transformed = proj4("EPSG:25832", "EPSG:4326", coord);
                                return [transformed[0], transformed[1]];
                            });
                        });
                    });
                    console.log("Transformed Polygon/MultiPolygon:", feature.geometry.coordinates);
                }
            }
            return feature;
        }

        function addPointGeoJsonLayer(url, layerGroup, layerName, color) {
            console.log(`Fetching ${layerName} data from: ${url}`);
            fetch(url)
                .then(response => {
                    console.log(`${layerName} data request successful:`, response);
                    return response.json();
                })
                .then(data => {
                    console.log(`${layerName} GeoJSON received:`, data);
                    if (data && data.features) {
                        console.log(`Processing ${data.features.length} features for ${layerName}`);
                        data.features.forEach(feature => {
                            const transformedFeature = transformCoordinates(feature);
                            if (transformedFeature.geometry && transformedFeature.geometry.type === 'Point' && transformedFeature.geometry.coordinates) {
                                L.circleMarker([transformedFeature.geometry.coordinates[1], transformedFeature.geometry.coordinates[0]], {
                                    radius: 5,
                                    fillColor: color,
                                    color: color,
                                    weight: 1,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                }).bindPopup(`${layerName} ID: ${transformedFeature.properties.id}`).addTo(layerGroup);
                            } else {
                                console.warn(`Feature missing point geometry for ${layerName}:`, feature);
                            }
                        });
                        // No need to addTo(map) here, the layerGroup is added to the control
                        console.log(`${layerName} points added to layer group.`);
                    } else {
                        console.error(`Invalid GeoJSON format for ${layerName}`, data);
                    }
                })
                .catch(error => {
                    console.error(`Error fetching ${layerName} data:`, error);
                });
        }

        // Add the new point layers using the dedicated function
        addPointGeoJsonLayer('/Map/SykehusGeoJson', sykehusLayer, 'Sykehus', 'blue');
        addPointGeoJsonLayer('/Map/PolitiFengselGeoJson', politiLayer, 'Politi/Fengsel', 'green');
        addPointGeoJsonLayer('/Map/BrannAmbulanseGeoJson', brannLayer, 'Brann/Ambulanse', 'red');
    </script>


}
